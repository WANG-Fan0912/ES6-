<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div>打开控制台查看结果</div>

    <script>
        console.log('=========Proxy=========');
        // let proxy = new Proxy(target,handler)
        /* Proxy对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。
           new Proxy()用来生成一个Proxy实例，
           target参数表示要拦截的目标对象，
           handler参数是一个对象，用来定制拦截行为。
        */

        /* 案例：拦截读取属性行为 */
       let proxy2 = new Proxy({},{
        get: function(target,propKey){
            return 10;
        }
       })
       proxy2.time = 20;
       console.log(proxy2.time);  // 10
       console.log(proxy2.name);  // 10
       /* 上面代码中，作为构造函数，Proxy接受两个参数
          第一个参数：要代理的目标对象（在本例中是一个空对象）
          第二个参数：配置对象，对于每一个被代理的操作，需要提供一个对象的处理函数，该处理函数将拦截对应的操作。
          上面代码中，配置对象有一个get方法，用来拦截对目标对象属性的访问请求。
          get方法的两个参数分别是目标对象和所要访问的属性。
          这里的拦截函数返回 10 ，所以访问任何属性都得到 10
          也就是说，给目标对象添加了属性值，但是在访问这一层被拦截了，任何访问都会返回拦截的这一层
       */

       // 注意：要是Proxy生效，就必须对Proxy实例（也就是上面的proxy2对象)进行操作，而不是针对目标对象（第一个参数的空对象）进行操作。

       // 如果handler（第二个参数）没有设置任何拦截，就等同于直接通向原对象。
        /* 案例：拦截读取属性行为 */
        let target = {}
        let handler = {}
        let proxy3 = new Proxy(target,handler)
       proxy3.time = 20;
       console.log(proxy3.time);  // 20
       //handler没有设置任何拦截效果，访问proxy就等于访问target

       /* 对象内是可以设置函数的，可以将Proxy对象设置到object.proxy属性，这样就可以在object对象上调用 */
       let object = { proxy : new Proxy(target,handler) }

       /* Proxy实例也可以作为其它对象的原型对象 */
       let proxy4 = new Proxy({},{
        get : function(target,propKsy){
            return 10
        }
       })
       let obj = Object.create(proxy4)
       console.log(obj.time);  // {time: 10}    Prototype:Proxy
       /* 上面这段代码中，proxy4对象是obj对象的原型，obj对象本身并没有time属性，所以根据原型链，会在proxy4对象上读取该对象，导致被拦截 */

       /* 同一个拦截器函数，可以设置拦截多个操作 */
       let hand = {
        get : function(target,name){
            if(name === 'prototype'){
                return Object.prototype
            }
            return 'hello,'+name;
        },
        apply:function(target,thisBinding,args){
            return args[0]
        },
        construct:function(target,args){
            return {value:args[1]}
        }
       }
       let fproxy = new Proxy(function(x,y){
        return x + y
       },hand)

       console.log(fproxy(1,2));  // 1
       console.log(new fproxy(1,2));  // {value:2}
       console.log(fproxy.prototype === Object.prototype); // true
       console.log(fproxy.foo = 'Hello,foo');  // Hello,foo

       /* Proxy支持的拦截操作，一共13种 */
       /* 
        1、 get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy['foo']。

        2、set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值。

        3、has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。

        4、deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。
        
        5、ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。
       
        6、getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。
        
        7、defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。
       
        8、preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。
       
        9、getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。
       
        10、isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。
       
        11、setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。
       
        12、apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。
       
        13、construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。
       */

       console.log('==========Proxy实例的方法==========');
       /* 此处为上面拦截方法的详细介绍 */
       /* get()
          用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和proxy实例本身（操作指向的对象），最后一个参数为可选参数。
       */
      let person = {
        name : '张三'
      }
      let proxy = new Proxy(person,{
        get:function(target,propKey){
            if(propKey in target){
                return target[propKey]
            } else {
                throw new ReferenceError("Prop name \"" + propKey + "\" does not exist.")
            }
        }
      })
      console.log(proxy.name);  // 张三
    //   console.log(proxy.age);  // 抛出错误 Uncaught ReferenceError: Prop name "age" does not exist.
    /* 上面代码表示，如果访问目标对象不存在的属性，会抛出错误。如果没有这个拦截函数，访问不存在的属性会返回undefined */
    
    /* get方法可以继承 */
    let proto = new Proxy({},{
        get(target,propertyKey,receiver){
            console.log('GET'+propertyKey);
            return target[propertyKey]
        }
    });
    let obj2 = Object.create(proto)
    obj2.foo  // GETfoo
    


       



    </script>
</body>
</html>