<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div>打开控制台查看结果</div>

    <script>
        console.log('================Generator============');
        /* 
           概念：Generator函数是ES6提供的一种一部变成解决方案
           Generator函数是一个状态机，封装了多个内部状态。
           执行Generator函数会返回一个遍历器对象，也就是说Generator还是一个遍历器对象生成函数。
           返回的遍历器对象可以一次遍历Generator函数内部的每一个状态。
        */

        /* 
           表面上，Generator函数是一个普通函数，但它有两个特征。
           一：functiong关键字与函数名之间有一个星号。
           二：函数内部使用yield表达式，定义不同的内部状态。（yield翻译为产出）
        */
         function* hello(){
            yield 'hello';
            yield 'world';
            return 'hi'
         }
         let h = hello()
         console.log(h);  // hello {<suspended>}
         /* 上面代码定义了Generator函数hello，函数内部有两个yield表达式（hello、world),那么该函数就有三个状态：hello、world、return语句（结束执行） */
         
         /* 表面上看Generator在写法上与普通的函数一样，但实际上，Generator函数调用后并不会执行，而且返回的也不是函数运行结果，而是指向内部状态的指针对象，也就是遍历器对象（Iterator Object)
            
            调用遍历器对象next方法，使指针移向下一个状态，每次调用next，内部指针就从函数头部或者上一次停下来的地方开始执行，直到遇到下一个yield或return为止。也就是说，Generator函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。
         */
        console.log(h.next());  // {value: 'hello', done: false}
        console.log(h.next());  // {value: 'world', done: false}
        console.log(h.next());  // {value: 'hi', done: true}
        console.log(h.next());  // {value: undefined, done: true}
        /* 调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。 */

        // Generator函数的星号并没有规定位置，所以下面的几种写法都可以
        function* f(){}  // 最常用的
        function * f(){}
        function *f(){}
        function*  f(){}

        console.log('=============yield表达式================');
        /* 
           Generator函数返回遍历器对象，只有调用next方法才会遍历下一个内部状态。
           
           1、其实，yield表达式就是一个暂停表示，当next执行后，遇到yield表达式会暂停执行后面的操作，并紧跟在yield后面的表达式，并返回当前遍历对象的value属性值。

           2、下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。

           3、如果没有遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后的表达式值返回。

           4、如果函数内没有return，则返回的对象value属性值为undefined

           注意：yield表达式后的表达式，只有当调用next方法、内部指针指向该语句时才会执行，也就相当于js提供了手动的“惰性求值”语法功能。
        */

        /* yield后的表达式立即求值，只有next方法将指针移到这一句时才会求值。 */
       function* sum(){
        yield 1+2;
       }
       console.log(sum());  // sum {<suspended>}
       console.log(sum().next());  // {value: 3, done: false}

       /* 
          yield与return的区别：

          相同：
          1、都能使函数暂停执行
          2、都能返回紧跟在语句后面的表达式的值。

          不同：
          1、yield具有位置记忆功能，return没有
          2、一个函数内，只能执行一次（一个）return语句，而yield表达式可以执行多次（多个）
          3、正常函数只能执行一次return，（执行return后函数停止），而Generator函数可以返回一系列值，因为可以有任意多个yield。
       */

       /* Genarator内不用yield表达式，这时就变成了一个单纯的暂缓执行函数。 */
       function* fn() {
          console.log('执行了11')
          console.log('执行了22')
        }
        fn();  // 没有任何执行
        fn().next()  // 执行了11  执行了22

        /* yield只能再在Generator函数内，用在其它地方会报错 */
        function fn2(){
            // yield 100;  // 报错 Unexpected number 
        }

      /* yeild表达式如果用在另一个表达式中，必须放在圆括号里 */
      function* demo(){
         // console.log('hello' + yield); // Uncaught SyntaxError: Unexpected identifier 'yield'
         console.log("hello" + (yield));  // 不报错
      }
      /* 如果yield表达式用作函数参数或放在赋值表达式右边，可以不加括号 */
      function* deom2(){
         foo(yield 'a' , yield 'b');
         let s = yield;
      }

      console.log('=========next方法的参数==========');
      /* yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式返回的值。
         我们可以利用这个特性，来让Generator函数分阶段执行不同的行为。
      */
   //   案例一
   function* f(){
      for(let i = 0;true;i++){
         let reset = yield i;
         if(reset){ i = -1 }
      }
   }
   let g= f()
   console.log(g.next()); // {value: 0, done: false}
   console.log(g.next()); // {value: 1, done: false}
   console.log(g.next()); // {value: 2, done: false}
   console.log(g.next(true)); // {value: 0, done: false}
   console.log(g.next()); // {value: 1, done: false}
   /* 案例一中，定义了一个无限循环的for
   next第一遍，运行到yield这里停止，这里yield后面的i结果为0
   next第二遍，运行到yield这里停止这里yield后面的i结果为2
   前两次next，yield没有参数，那么yield返回的是undefined，直到第三次next，传入一个true
   next第三遍，reset等于true，进入判断更改i的值为-1,遍历的i从-1开始
    */

    /* next可以让Generator函数从暂停状态到恢复运行，Generator的上下文状态时不变的，但是我们可以通过next方法的参数，让Generator函数开始运行时，往内部注入值，让Generator函数在运行的不同阶段，通过该参数调整函数行为。 */
    
   








    </script>
</body>
</html>